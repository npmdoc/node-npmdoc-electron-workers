<html><head></head><body><div class="apidocDiv">
<style>
/*csslint
*/
.apidocDiv {
    background: #fff;
    font-family: Arial, Helvetica, sans-serif;
}
.apidocDiv a[href] {
    color: #33f;
    font-weight: bold;
    text-decoration: none;
}
.apidocDiv a[href]:hover {
    text-decoration: underline;
}
.apidocCodeCommentSpan {
    background: #bbf;
    color: #000;
    display: block;
}
.apidocCodeKeywordSpan {
    color: #d00;
    font-weight: bold;
}
.apidocCodePre {
    background: #eef;
    border: 1px solid;
    color: #777;
    padding: 5px;
    white-space: pre-wrap;
}
.apidocFooterDiv {
    margin-top: 20px;
    text-align: center;
}
.apidocModuleLi {
    margin-top: 10px;
}
.apidocSectionDiv {
    border-top: 1px solid;
    margin-top: 20px;
}
.apidocSignatureSpan {
    color: #777;
    font-weight: bold;
}
</style>
<h1>api documentation for
    <a href="https://github.com/bjrmatos/electron-workers">electron-workers (v1.10.1)</a>
</h1>
<h4>Run electron scripts in managed workers</h4>
<div class="apidocSectionDiv"><a href="#apidoc.tableOfContents" id="apidoc.tableOfContents"><h1>table of contents</h1></a><ol>

    <li class="apidocModuleLi"><a href="#apidoc.module.electron-workers">module electron-workers</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.electron-workers.electron-workers">
            function <span class="apidocSignatureSpan"></span>electron-workers
            <span class="apidocSignatureSpan">(options)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.electron-workers.ElectronManager">
            function <span class="apidocSignatureSpan">electron-workers.</span>ElectronManager
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.electron-workers.ElectronWorker">
            function <span class="apidocSignatureSpan">electron-workers.</span>ElectronWorker
            <span class="apidocSignatureSpan">(options)</span>
            </a>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">electron-workers.</span>ElectronManager.prototype</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">electron-workers.</span>ElectronWorker.prototype</span>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.electron-workers.ElectronManager">module electron-workers.ElectronManager</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.electron-workers.ElectronManager.ElectronManager">
            function <span class="apidocSignatureSpan">electron-workers.</span>ElectronManager
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.electron-workers.ElectronManager.prototype">module electron-workers.ElectronManager.prototype</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.electron-workers.ElectronManager.prototype._executeInWorker">
            function <span class="apidocSignatureSpan">electron-workers.ElectronManager.prototype.</span>_executeInWorker
            <span class="apidocSignatureSpan">(worker, data, options, cb)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.electron-workers.ElectronManager.prototype._manageTaskEndInWorker">
            function <span class="apidocSignatureSpan">electron-workers.ElectronManager.prototype.</span>_manageTaskEndInWorker
            <span class="apidocSignatureSpan">(worker)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.electron-workers.ElectronManager.prototype._manageTaskStartInWorker">
            function <span class="apidocSignatureSpan">electron-workers.ElectronManager.prototype.</span>_manageTaskStartInWorker
            <span class="apidocSignatureSpan">(worker)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.electron-workers.ElectronManager.prototype.execute">
            function <span class="apidocSignatureSpan">electron-workers.ElectronManager.prototype.</span>execute
            <span class="apidocSignatureSpan">(data)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.electron-workers.ElectronManager.prototype.kill">
            function <span class="apidocSignatureSpan">electron-workers.ElectronManager.prototype.</span>kill
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.electron-workers.ElectronManager.prototype.start">
            function <span class="apidocSignatureSpan">electron-workers.ElectronManager.prototype.</span>start
            <span class="apidocSignatureSpan">(cb)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.electron-workers.ElectronManager.prototype.tryFlushQueue">
            function <span class="apidocSignatureSpan">electron-workers.ElectronManager.prototype.</span>tryFlushQueue
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.electron-workers.ElectronWorker">module electron-workers.ElectronWorker</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.electron-workers.ElectronWorker.ElectronWorker">
            function <span class="apidocSignatureSpan">electron-workers.</span>ElectronWorker
            <span class="apidocSignatureSpan">(options)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.electron-workers.ElectronWorker.prototype">module electron-workers.ElectronWorker.prototype</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.electron-workers.ElectronWorker.prototype.checkAlive">
            function <span class="apidocSignatureSpan">electron-workers.ElectronWorker.prototype.</span>checkAlive
            <span class="apidocSignatureSpan">(cb, shot)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.electron-workers.ElectronWorker.prototype.execute">
            function <span class="apidocSignatureSpan">electron-workers.ElectronWorker.prototype.</span>execute
            <span class="apidocSignatureSpan">(data, cb)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.electron-workers.ElectronWorker.prototype.kill">
            function <span class="apidocSignatureSpan">electron-workers.ElectronWorker.prototype.</span>kill
            <span class="apidocSignatureSpan">(hardKill)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.electron-workers.ElectronWorker.prototype.onWorkerProcessError">
            function <span class="apidocSignatureSpan">electron-workers.ElectronWorker.prototype.</span>onWorkerProcessError
            <span class="apidocSignatureSpan">(workerProcessErr)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.electron-workers.ElectronWorker.prototype.onWorkerProcessExitTryToRecyle">
            function <span class="apidocSignatureSpan">electron-workers.ElectronWorker.prototype.</span>onWorkerProcessExitTryToRecyle
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.electron-workers.ElectronWorker.prototype.onWorkerProcessIpcMessage">
            function <span class="apidocSignatureSpan">electron-workers.ElectronWorker.prototype.</span>onWorkerProcessIpcMessage
            <span class="apidocSignatureSpan">(payload)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.electron-workers.ElectronWorker.prototype.recycle">
            function <span class="apidocSignatureSpan">electron-workers.ElectronWorker.prototype.</span>recycle
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.electron-workers.ElectronWorker.prototype.start">
            function <span class="apidocSignatureSpan">electron-workers.ElectronWorker.prototype.</span>start
            <span class="apidocSignatureSpan">(cb)</span>
            </a>

        </li>

    </ol></li>

</ol></div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.electron-workers" id="apidoc.module.electron-workers">module electron-workers</a></h1>


    <h2>
        <a href="#apidoc.element.electron-workers.electron-workers" id="apidoc.element.electron-workers.electron-workers">
        function <span class="apidocSignatureSpan"></span>electron-workers
        <span class="apidocSignatureSpan">(options)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function electronManager(options) {
  return createManager(options);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.electron-workers.ElectronManager" id="apidoc.element.electron-workers.ElectronManager">
        function <span class="apidocSignatureSpan">electron-workers.</span>ElectronManager
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function ElectronManager() {
  var options = arguments.length &lt;= 0 || arguments[0] === undefined ? {} : arguments[0];

  _classCallCheck(this, ElectronManager);

  _EventEmitter.call(this);

  var instance = this;

  this._electronInstances = [];
  this._electronInstancesTasksCount = {};
  this.options = _extends({}, options);
  this.options.connectionMode = this.options.connectionMode || 'server';
  this.options.electronArgs = this.options.electronArgs || [];
  this.options.pathToElectron = this.options.pathToElectron || getElectronPath();
  this.options.numberOfWorkers = this.options.numberOfWorkers || numCPUs;
  this.options.maxConcurrencyPerWorker = this.options.maxConcurrencyPerWorker || Infinity;
  this.options.timeout = this.options.timeout || 10000;
  this.options.host = this.options.host || 'localhost';
  this.options.hostEnvVarName = this.options.hostEnvVarName || 'ELECTRON_WORKER_HOST';
  this.options.portEnvVarName = this.options.portEnvVarName || 'ELECTRON_WORKER_PORT';
  this._timeouts = [];
  this.tasksQueue = [];

  if (isNaN(this.options.maxConcurrencyPerWorker) || typeof this.options.maxConcurrencyPerWorker !== 'number') {
    throw new Error('`maxConcurrencyPerWorker` option must be a number');
  }

  if (this.options.maxConcurrencyPerWorker &lt;= 0) {
    throw new Error('`maxConcurrencyPerWorker` option must be greater than 0');
  }

  function processExitHandler() {
    debugManager('process exit: trying to kill workers..');
    instance.kill();
  }

  this._processExitHandler = processExitHandler;

  process.once('exit', processExitHandler);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.electron-workers.ElectronWorker" id="apidoc.element.electron-workers.ElectronWorker">
        function <span class="apidocSignatureSpan">electron-workers.</span>ElectronWorker
        <span class="apidocSignatureSpan">(options)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function ElectronWorker(options) {
  _classCallCheck(this, ElectronWorker);

  _EventEmitter.call(this);

  this.options = options;
  this.firstStart = false;
  this.shouldRevive = false;
  this.exit = false;
  this.isBusy = false;
  this.isRecycling = false;
  this.id = _uuid2['default'].v1();
  this._hardKill = false;
  this._earlyError = false;
  this._taskCallback = {};

  this.onWorkerProcessError = this.onWorkerProcessError.bind(this);
  this.onWorkerProcessExitTryToRecyle = this.onWorkerProcessExitTryToRecyle.bind(this);
  this.onWorkerProcessIpcMessage = this.onWorkerProcessIpcMessage.bind(this);

  if (options.connectionMode === 'ipc') {
    this.findFreePort = function (cb) {
      cb(null);
    };
  } else {
    if (options.portLeftBoundary &amp;&amp; options.portRightBoundary) {
      this.findFreePort = function (cb) {
        findFreePortInRange(options.host, options.portLeftBoundary, options.portRightBoundary, cb);
      };
    } else {
      this.findFreePort = function (cb) {
        findFreePort(options.host, cb);
      };
    }
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>






</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.electron-workers.ElectronManager" id="apidoc.module.electron-workers.ElectronManager">module electron-workers.ElectronManager</a></h1>


    <h2>
        <a href="#apidoc.element.electron-workers.ElectronManager.ElectronManager" id="apidoc.element.electron-workers.ElectronManager.ElectronManager">
        function <span class="apidocSignatureSpan">electron-workers.</span>ElectronManager
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function ElectronManager() {
  var options = arguments.length &lt;= 0 || arguments[0] === undefined ? {} : arguments[0];

  _classCallCheck(this, ElectronManager);

  _EventEmitter.call(this);

  var instance = this;

  this._electronInstances = [];
  this._electronInstancesTasksCount = {};
  this.options = _extends({}, options);
  this.options.connectionMode = this.options.connectionMode || 'server';
  this.options.electronArgs = this.options.electronArgs || [];
  this.options.pathToElectron = this.options.pathToElectron || getElectronPath();
  this.options.numberOfWorkers = this.options.numberOfWorkers || numCPUs;
  this.options.maxConcurrencyPerWorker = this.options.maxConcurrencyPerWorker || Infinity;
  this.options.timeout = this.options.timeout || 10000;
  this.options.host = this.options.host || 'localhost';
  this.options.hostEnvVarName = this.options.hostEnvVarName || 'ELECTRON_WORKER_HOST';
  this.options.portEnvVarName = this.options.portEnvVarName || 'ELECTRON_WORKER_PORT';
  this._timeouts = [];
  this.tasksQueue = [];

  if (isNaN(this.options.maxConcurrencyPerWorker) || typeof this.options.maxConcurrencyPerWorker !== 'number') {
    throw new Error('`maxConcurrencyPerWorker` option must be a number');
  }

  if (this.options.maxConcurrencyPerWorker &lt;= 0) {
    throw new Error('`maxConcurrencyPerWorker` option must be greater than 0');
  }

  function processExitHandler() {
    debugManager('process exit: trying to kill workers..');
    instance.kill();
  }

  this._processExitHandler = processExitHandler;

  process.once('exit', processExitHandler);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.electron-workers.ElectronManager.prototype" id="apidoc.module.electron-workers.ElectronManager.prototype">module electron-workers.ElectronManager.prototype</a></h1>


    <h2>
        <a href="#apidoc.element.electron-workers.ElectronManager.prototype._executeInWorker" id="apidoc.element.electron-workers.ElectronManager.prototype._executeInWorker">
        function <span class="apidocSignatureSpan">electron-workers.ElectronManager.prototype.</span>_executeInWorker
        <span class="apidocSignatureSpan">(worker, data, options, cb)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function _executeInWorker(worker, data, options, cb) {
  var _this2 = this;

  if (options === undefined) options = {};

  var workerTimeout = undefined;

  if (options.timeout != null) {
    workerTimeout = options.timeout;
  } else {
    workerTimeout = this.options.timeout;
  }

  if (worker.shouldRevive) {
    debugManager('trying to revive worker [' + worker.id + ']..');

    worker.start(function (startErr) {
      if (startErr) {
        debugManager('worker [' + worker.id + '] could not revive..');
        _this2.tryFlushQueue();
        return cb(startErr);
      }

      debugManager('worker [' + worker.id + '] has revived..');
      executeTask.call(_this2);
    });
  } else {
    executeTask.call(this);
  }

  function executeTask() {
    var _this3 = this;

    var isDone = false;

    var timeoutId = setTimeout(function () {
      _this3._timeouts.splice(_this3._timeouts.indexOf(timeoutId), 1);

      if (isDone) {
        return;
      }

      debugManager('task timeout in worker [' + worker.id + '] has been reached..');

      isDone = true;

      _this3._manageTaskEndInWorker(worker);

      _this3.emit('workerTimeout', worker);

      var error = new Error();
      error.workerTimeout = true;
      error.message = 'Worker Timeout, the worker process does not respond after ' + workerTimeout + ' ms';
      cb(error);

      _this3.tryFlushQueue();
    }, workerTimeout);

    debugManager('executing task in worker [' + worker.id + '] with timeout:', workerTimeout);

    this._timeouts.push(timeoutId);

    worker.execute(data, function (err, result) {
      if (isDone) {
        return;
      }

      _this3._manageTaskEndInWorker(worker);

      // clear timeout
      _this3._timeouts.splice(_this3._timeouts.indexOf(timeoutId), 1);
      clearTimeout(timeoutId);

      if (err) {
        debugManager('task has failed in worker [' + worker.id + ']..');
        _this3.tryFlushQueue();
        cb(err);
        return;
      }

      isDone = true;
      debugManager('task executed correctly in worker [' + worker.id + ']..');
      _this3.tryFlushQueue();
      cb(null, result);
    });
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
if (availableWorkerInstanceIndex !== -1) {
  availableWorkerInstance = this._electronInstances.splice(availableWorkerInstanceIndex, 1)[0];

  this._manageTaskStartInWorker(availableWorkerInstance);

  debugManager('worker [' + availableWorkerInstance.id + '] has been choosen for the task..');

  this.<span class="apidocCodeKeywordSpan">_executeInWorker</span>(availableWorkerInstance, data, options, cb);
  // ..and then the worker we have used becomes the last item in the list
  this._electronInstances.push(availableWorkerInstance);
  return;
}

debugManager('no workers available, storing the task for later processing..');
// if no available worker save task for later processing
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.electron-workers.ElectronManager.prototype._manageTaskEndInWorker" id="apidoc.element.electron-workers.ElectronManager.prototype._manageTaskEndInWorker">
        function <span class="apidocSignatureSpan">electron-workers.ElectronManager.prototype.</span>_manageTaskEndInWorker
        <span class="apidocSignatureSpan">(worker)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function _manageTaskEndInWorker(worker) {
  var maxConcurrencyPerWorker = this.options.maxConcurrencyPerWorker;

  if (this._electronInstancesTasksCount[worker.id] == null) {
    this._electronInstancesTasksCount[worker.id] = 0;
  }

  if (this._electronInstancesTasksCount[worker.id] &gt; 0) {
    this._electronInstancesTasksCount[worker.id]--;
  }

  if (this._electronInstancesTasksCount[worker.id] &lt; maxConcurrencyPerWorker) {
    worker.isBusy = false; // eslint-disable-line no-param-reassign
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
  return;
}

debugManager('task timeout in worker [' + worker.id + '] has been reached..');

isDone = true;

_this3.<span class="apidocCodeKeywordSpan">_manageTaskEndInWorker</span>(worker);

_this3.emit('workerTimeout', worker);

var error = new Error();
error.workerTimeout = true;
error.message = 'Worker Timeout, the worker process does not respond after ' + workerTimeout + ' ms';
cb(error);
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.electron-workers.ElectronManager.prototype._manageTaskStartInWorker" id="apidoc.element.electron-workers.ElectronManager.prototype._manageTaskStartInWorker">
        function <span class="apidocSignatureSpan">electron-workers.ElectronManager.prototype.</span>_manageTaskStartInWorker
        <span class="apidocSignatureSpan">(worker)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function _manageTaskStartInWorker(worker) {
  var maxConcurrencyPerWorker = this.options.maxConcurrencyPerWorker;

  if (this._electronInstancesTasksCount[worker.id] == null) {
    this._electronInstancesTasksCount[worker.id] = 0;
  }

  if (this._electronInstancesTasksCount[worker.id] &lt; maxConcurrencyPerWorker) {
    this._electronInstancesTasksCount[worker.id]++;
  }

  // "equality check" is just enough here but we apply the "greater than" check just in case..
  if (this._electronInstancesTasksCount[worker.id] &gt;= maxConcurrencyPerWorker) {
    worker.isBusy = true; // eslint-disable-line no-param-reassign
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
    availableWorkerInstanceIndex = _lodashFindindex2['default'](this._electronInstances, {
isBusy: false
    });

    if (availableWorkerInstanceIndex !== -1) {
availableWorkerInstance = this._electronInstances.splice(availableWorkerInstanceIndex, 1)[0];

this.<span class="apidocCodeKeywordSpan">_manageTaskStartInWorker</span>(availableWorkerInstance);

debugManager('worker [' + availableWorkerInstance.id + '] has been choosen for the task..');

this._executeInWorker(availableWorkerInstance, data, options, cb);
// ..and then the worker we have used becomes the last item in the list
this._electronInstances.push(availableWorkerInstance);
return;
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.electron-workers.ElectronManager.prototype.execute" id="apidoc.element.electron-workers.ElectronManager.prototype.execute">
        function <span class="apidocSignatureSpan">electron-workers.ElectronManager.prototype.</span>execute
        <span class="apidocSignatureSpan">(data)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function execute(data) {
  var availableWorkerInstanceIndex = undefined,
      availableWorkerInstance = undefined,
      options = undefined,
      cb = undefined;

  for (var _len = arguments.length, args = Array(_len &gt; 1 ? _len - 1 : 0), _key = 1; _key &lt; _len; _key++) {
    args[_key - 1] = arguments[_key];
  }

  if (args.length &gt; 1) {
    options = args[0];
    cb = args[1];
  } else {
    cb = args[0];
  }

  debugManager('getting new task..');

  // simple round robin balancer across workers
  // on each execute, get the first available worker from the list...
  availableWorkerInstanceIndex = _lodashFindindex2['default'](this._electronInstances, {
    isBusy: false
  });

  if (availableWorkerInstanceIndex !== -1) {
    availableWorkerInstance = this._electronInstances.splice(availableWorkerInstanceIndex, 1)[0];

    this._manageTaskStartInWorker(availableWorkerInstance);

    debugManager('worker [' + availableWorkerInstance.id + '] has been choosen for the task..');

    this._executeInWorker(availableWorkerInstance, data, options, cb);
    // ..and then the worker we have used becomes the last item in the list
    this._electronInstances.push(availableWorkerInstance);
    return;
  }

  debugManager('no workers available, storing the task for later processing..');
  // if no available worker save task for later processing
  this.tasksQueue.push({ data: data, options: options, cb: cb });
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...

electronWorkers.start(function(startErr) {
if (startErr) {
  return console.error(startErr);
}

// `electronWorkers` will send your data in a POST request to your electron script
electronWorkers.<span class="apidocCodeKeywordSpan">execute</span>({ someData: 'someData' }, function(err, data) {
  if (err) {
    return console.error(err);
  }

  console.log(JSON.stringify(data)); // { someData: 'someData' }
  electronWorkers.kill(); // kill all workers explicitly
});
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.electron-workers.ElectronManager.prototype.kill" id="apidoc.element.electron-workers.ElectronManager.prototype.kill">
        function <span class="apidocSignatureSpan">electron-workers.ElectronManager.prototype.</span>kill
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function kill() {
  debugManager('killing all workers..');

  this._timeouts.forEach(function (tId) {
    clearTimeout(tId);
  });

  this._electronInstances.forEach(function (workerInstance) {
    workerInstance.kill(true);
  });

  process.removeListener('exit', this._processExitHandler);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
  // `electronWorkers` will send your data in a POST request to your electron script
  electronWorkers.execute({ someData: 'someData' }, function(err, data) {
    if (err) {
      return console.error(err);
    }

    console.log(JSON.stringify(data)); // { someData: 'someData' }
    electronWorkers.<span class="apidocCodeKeywordSpan">kill</span>(); // kill all workers explicitly
  });
});
```

### How to use ipc mode

1.- First create an electron script
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.electron-workers.ElectronManager.prototype.start" id="apidoc.element.electron-workers.ElectronManager.prototype.start">
        function <span class="apidocSignatureSpan">electron-workers.ElectronManager.prototype.</span>start
        <span class="apidocSignatureSpan">(cb)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function start(cb) {
  var _this = this;

  var started = 0;
  var workerErrors = [];
  var _options = this.options;
  var numberOfWorkers = _options.numberOfWorkers;
  var connectionMode = _options.connectionMode;
  var couldNotStartWorkersErr = undefined;

  if (connectionMode !== 'server' &amp;&amp; connectionMode !== 'ipc') {
    return cb(new Error('invalid connection mode: ' + connectionMode));
  }

  debugManager('starting ' + numberOfWorkers + ' worker(s), mode: ' + connectionMode + '..');

  function startHandler(err) {
    if (err) {
      workerErrors.push(err);
    }

    started++;

    if (started === numberOfWorkers) {
      if (workerErrors.length) {
        couldNotStartWorkersErr = new Error('electron manager could not start all workers..');
        couldNotStartWorkersErr.workerErrors = workerErrors;
        debugManager('electron manager could not start all workers..');
        return cb(couldNotStartWorkersErr);
      }

      debugManager('all workers started correctly');
      cb(null);
    }
  }

  var _loop = function (ix) {
    var workerPortLeftBoundary = _this.options.portLeftBoundary,
        workerOptions = undefined,
        workerInstance = undefined;

    // prevent that workers start with the same left boundary
    if (workerPortLeftBoundary != null) {
      workerPortLeftBoundary += ix;
    }

    workerOptions = {
      debug: _this.options.debug,
      debugBrk: _this.options.debugBrk,
      env: _this.options.env,
      stdio: _this.options.stdio,
      connectionMode: _this.options.connectionMode,
      killSignal: _this.options.killSignal,
      electronArgs: _this.options.electronArgs,
      pathToElectron: _this.options.pathToElectron,
      pathToScript: _this.options.pathToScript,
      hostEnvVarName: _this.options.hostEnvVarName,
      portEnvVarName: _this.options.portEnvVarName,
      host: _this.options.host,
      portLeftBoundary: workerPortLeftBoundary,
      portRightBoundary: _this.options.portRightBoundary
    };

    debugManager('creating worker ' + (ix + 1) + ' with options:', workerOptions);
    workerInstance = new _ElectronWorker2['default'](workerOptions);

    workerInstance.on('processCreated', function () {
      _this.emit('workerProcessCreated', workerInstance, workerInstance._childProcess);
    });

    workerInstance.on('recycling', function () {
      if (_this._electronInstancesTasksCount[workerInstance.id] != null) {
        _this._electronInstancesTasksCount[workerInstance.id] = 0;
      }

      _this.emit('workerRecycling', workerInstance);
    });

    workerInstance.on('recyclingError', function () {
      _this.emit('workerRecyclingError', workerInstance);
      _this.tryFlushQueue();
    });

    workerInstance.on('recycled', function () {
      _this.emit('workerRecycled', workerInstance);
      _this.tryFlushQueue();
    });

    workerInstance.on('kill', function () {
      if (_this._electronInstancesTasksCount[workerInstance.id] != null) {
        _this._electronInstancesTasksCount[workerInstance.id] = 0;
      }
    });

    _this._electronInstances.push(workerInstance);
    _this._electronInstancesTasksCount[workerInstance.id] = 0;

    _this._electronInstances[ix].start(startHandler);
  };

  for (var ix = 0; ix &lt; numberOfWorkers; ix++) {
    _loop(ix);
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
var electronWorkers = require('electron-workers')({
connectionMode: 'server',
pathToScript: 'script.js',
timeout: 5000,
numberOfWorkers: 5
});

electronWorkers.<span class="apidocCodeKeywordSpan">start</span>(function(startErr) {
if (startErr) {
  return console.error(startErr);
}

// `electronWorkers` will send your data in a POST request to your electron script
electronWorkers.execute({ someData: 'someData' }, function(err, data) {
  if (err) {
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.electron-workers.ElectronManager.prototype.tryFlushQueue" id="apidoc.element.electron-workers.ElectronManager.prototype.tryFlushQueue">
        function <span class="apidocSignatureSpan">electron-workers.ElectronManager.prototype.</span>tryFlushQueue
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function tryFlushQueue() {
  var availableWorkerInstanceIndex = undefined,
      availableWorkerInstance = undefined,
      task = undefined;

  debugManager('trying to flush queue of pending tasks..');

  if (this.tasksQueue.length === 0) {
    debugManager('there is no pending tasks..');
    return;
  }

  // simple round robin balancer across workers
  // get the first available worker from the list...
  availableWorkerInstanceIndex = _lodashFindindex2['default'](this._electronInstances, {
    isBusy: false
  });

  if (availableWorkerInstanceIndex === -1) {
    debugManager('no workers available to process pending task..');
    return;
  }

  task = this.tasksQueue.shift();
  availableWorkerInstance = this._electronInstances.splice(availableWorkerInstanceIndex, 1)[0];

  this._manageTaskStartInWorker(availableWorkerInstance);

  debugManager('worker [' + availableWorkerInstance.id + '] has been choosen for process pending task..');

  this._executeInWorker(availableWorkerInstance, task.data, task.options, task.cb);
  // ..and then the worker we have used becomes the last item in the list
  this._electronInstances.push(availableWorkerInstance);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
  }

  _this.emit('workerRecycling', workerInstance);
});

workerInstance.on('recyclingError', function () {
  _this.emit('workerRecyclingError', workerInstance);
  _this.<span class="apidocCodeKeywordSpan">tryFlushQueue</span>();
});

workerInstance.on('recycled', function () {
  _this.emit('workerRecycled', workerInstance);
  _this.tryFlushQueue();
});
...</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.electron-workers.ElectronWorker" id="apidoc.module.electron-workers.ElectronWorker">module electron-workers.ElectronWorker</a></h1>


    <h2>
        <a href="#apidoc.element.electron-workers.ElectronWorker.ElectronWorker" id="apidoc.element.electron-workers.ElectronWorker.ElectronWorker">
        function <span class="apidocSignatureSpan">electron-workers.</span>ElectronWorker
        <span class="apidocSignatureSpan">(options)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function ElectronWorker(options) {
  _classCallCheck(this, ElectronWorker);

  _EventEmitter.call(this);

  this.options = options;
  this.firstStart = false;
  this.shouldRevive = false;
  this.exit = false;
  this.isBusy = false;
  this.isRecycling = false;
  this.id = _uuid2['default'].v1();
  this._hardKill = false;
  this._earlyError = false;
  this._taskCallback = {};

  this.onWorkerProcessError = this.onWorkerProcessError.bind(this);
  this.onWorkerProcessExitTryToRecyle = this.onWorkerProcessExitTryToRecyle.bind(this);
  this.onWorkerProcessIpcMessage = this.onWorkerProcessIpcMessage.bind(this);

  if (options.connectionMode === 'ipc') {
    this.findFreePort = function (cb) {
      cb(null);
    };
  } else {
    if (options.portLeftBoundary &amp;&amp; options.portRightBoundary) {
      this.findFreePort = function (cb) {
        findFreePortInRange(options.host, options.portLeftBoundary, options.portRightBoundary, cb);
      };
    } else {
      this.findFreePort = function (cb) {
        findFreePort(options.host, cb);
      };
    }
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.electron-workers.ElectronWorker.prototype" id="apidoc.module.electron-workers.ElectronWorker.prototype">module electron-workers.ElectronWorker.prototype</a></h1>


    <h2>
        <a href="#apidoc.element.electron-workers.ElectronWorker.prototype.checkAlive" id="apidoc.element.electron-workers.ElectronWorker.prototype.checkAlive">
        function <span class="apidocSignatureSpan">electron-workers.ElectronWorker.prototype.</span>checkAlive
        <span class="apidocSignatureSpan">(cb, shot)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function checkAlive(cb, shot) {
  var shotCount = shot || 1,
      connectionMode = this.options.connectionMode;

  function statusHandler(err, statusWorker) {
    var _this3 = this;

    if (!err &amp;&amp; statusWorker === 'open') {
      return cb();
    }

    if (connectionMode === 'server' &amp;&amp; shotCount &gt; 50) {
      return cb(new Error('Unable to reach electron worker - mode: ' + connectionMode));
    }

    if (connectionMode === 'ipc' &amp;&amp; err) {
      return cb(err);
    }

    shotCount++;

    // re-try check
    if (connectionMode === 'server') {
      setTimeout(function () {
        _this3.checkAlive(cb, shotCount);
      }, 100);
    }
  }

  if (connectionMode === 'server') {
    _checkPortStatus2['default'](this.port, this.options.host, statusHandler.bind(this));
  } else if (connectionMode === 'ipc') {
    _checkIpcStatus2['default'](this._childProcess, statusHandler.bind(this));
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
        if (_this2._childProcess == null) {
debugWorker('There is no child process for worker [' + _this2.id + ']..');
return cb(new Error('There is no child process for worker'));
        }

        debugWorker('checking if worker [' + _this2.id + '] is alive..');

        _this2.<span class="apidocCodeKeywordSpan">checkAlive</span>(function (checkAliveErr) {
if (isDone) {
  return;
}

if (checkAliveErr) {
  debugWorker('worker [' + _this2.id + '] is not alive..');
  return cb(checkAliveErr);
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.electron-workers.ElectronWorker.prototype.execute" id="apidoc.element.electron-workers.ElectronWorker.prototype.execute">
        function <span class="apidocSignatureSpan">electron-workers.ElectronWorker.prototype.</span>execute
        <span class="apidocSignatureSpan">(data, cb)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function execute(data, cb) {
  var _this4 = this;

  var connectionMode = this.options.connectionMode,
      httpOpts = undefined,
      req = undefined,
      json = undefined,
      taskId = undefined;

  debugWorker('new task for worker [' + this.id + ']..');

  this.emit('task');

  if (this._hardKill) {
    debugWorker('task execution stopped because worker [' + this.id + '] was killed by the user..');
    return;
  }

  if (connectionMode === 'ipc') {
    debugWorker('creating ipc task message for worker [' + this.id + ']..');

    taskId = _uuid2['default'].v1();

    this._taskCallback[taskId] = function () {
      for (var _len = arguments.length, args = Array(_len), _key = 0; _key &lt; _len; _key++) {
        args[_key] = arguments[_key];
      }

      _this4.emit('taskEnd');
      cb.apply(undefined, args);
    };

    return this._childProcess.send({
      workerEvent: 'task',
      taskId: taskId,
      payload: data
    });
  }

  debugWorker('creating request for worker [' + this.id + ']..');

  httpOpts = {
    hostname: this.options.host,
    port: this.port,
    path: '/',
    method: 'POST'
  };

  req = _http2['default'].request(httpOpts, function (res) {
    var result = '';

    res.on('data', function (chunk) {
      result += chunk;
    });

    res.on('end', function () {
      var responseData = undefined;

      debugWorker('request in worker [' + _this4.id + '] has ended..');

      _this4.emit('taskEnd');

      try {
        debugWorker('trying to parse worker [' + _this4.id + '] response..');
        responseData = result ? JSON.parse(result) : null;
      } catch (err) {
        debugWorker('couldn\'t parse response for worker [' + _this4.id + ']..');
        return cb(err);
      }

      debugWorker('response has been parsed correctly for worker [' + _this4.id + ']..');
      cb(null, responseData);
    });
  });

  req.setHeader('Content-Type', 'application/json');
  json = JSON.stringify(data);
  req.setHeader('Content-Length', Buffer.byteLength(json));

  debugWorker('trying to communicate with worker [' + this.id + '], request options:', httpOpts, 'data:', json);

  req.write(json);

  req.on('error', function (err) {
    debugWorker('error when trying to communicate with worker [' + _this4.id + ']..');
    cb(err);
  });

  req.end();
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...

electronWorkers.start(function(startErr) {
if (startErr) {
  return console.error(startErr);
}

// `electronWorkers` will send your data in a POST request to your electron script
electronWorkers.<span class="apidocCodeKeywordSpan">execute</span>({ someData: 'someData' }, function(err, data) {
  if (err) {
    return console.error(err);
  }

  console.log(JSON.stringify(data)); // { someData: 'someData' }
  electronWorkers.kill(); // kill all workers explicitly
});
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.electron-workers.ElectronWorker.prototype.kill" id="apidoc.element.electron-workers.ElectronWorker.prototype.kill">
        function <span class="apidocSignatureSpan">electron-workers.ElectronWorker.prototype.</span>kill
        <span class="apidocSignatureSpan">(hardKill)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function kill(hardKill) {
  var connectionMode = this.options.connectionMode;

  debugWorker('killing worker [' + this.id + ']..');

  this.emit('kill');

  this._hardKill = Boolean(hardKill);

  if (this._childProcess) {
    if (this._childProcess.connected) {
      debugWorker('closing ipc connection - worker [' + this.id + ']..');
      this._childProcess.disconnect();
    }

    // clean previous listeners
    if (this._handleSpawnError) {
      this._childProcess.removeListener('error', this._handleSpawnError);
    }

    this._childProcess.removeListener('error', this.onWorkerProcessError);
    this._childProcess.removeListener('exit', this.onWorkerProcessExitTryToRecyle);

    if (connectionMode === 'ipc') {
      this._childProcess.removeListener('message', this.onWorkerProcessIpcMessage);
    }

    // guard against closing a process that has been closed before
    if (!this.exit) {
      if (this.options.killSignal) {
        debugWorker('killing worker [' + this.id + '] with custom signal:', this.options.killSignal);
        this._childProcess.kill(this.options.killSignal);
      } else {
        this._childProcess.kill();
      }

      if (!hardKill) {
        this.onWorkerProcessExitTryToRecyle();
      }
    }

    this._childProcess = undefined;
  } else {
    debugWorker('there is no child process to kill - worker [' + this.id + ']');
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
  // `electronWorkers` will send your data in a POST request to your electron script
  electronWorkers.execute({ someData: 'someData' }, function(err, data) {
    if (err) {
      return console.error(err);
    }

    console.log(JSON.stringify(data)); // { someData: 'someData' }
    electronWorkers.<span class="apidocCodeKeywordSpan">kill</span>(); // kill all workers explicitly
  });
});
```

### How to use ipc mode

1.- First create an electron script
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.electron-workers.ElectronWorker.prototype.onWorkerProcessError" id="apidoc.element.electron-workers.ElectronWorker.prototype.onWorkerProcessError">
        function <span class="apidocSignatureSpan">electron-workers.ElectronWorker.prototype.</span>onWorkerProcessError
        <span class="apidocSignatureSpan">(workerProcessErr)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function onWorkerProcessError(workerProcessErr) {
  debugWorker('worker [' + this.id + '] electron process error callback: ' + workerProcessErr.message);

  // don't handle early errors (errors between spawning the process and the first checkAlive call) in this handler
  if (this._earlyError) {
    debugWorker('worker [' + this.id + '] ignoring error because it was handled previously (early): ' + workerProcessErr.message
);
    return;
  }

  // try revive the process when an error is received,
  // note that could not be spawn errors are not handled here..
  if (this.firstStart &amp;&amp; !this.isRecycling &amp;&amp; !this.shouldRevive) {
    debugWorker('worker [' + this.id + '] the process will be revived because an error: ' + workerProcessErr.message);
    this.shouldRevive = true;
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.electron-workers.ElectronWorker.prototype.onWorkerProcessExitTryToRecyle" id="apidoc.element.electron-workers.ElectronWorker.prototype.onWorkerProcessExitTryToRecyle">
        function <span class="apidocSignatureSpan">electron-workers.ElectronWorker.prototype.</span>onWorkerProcessExitTryToRecyle
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function onWorkerProcessExitTryToRecyle() {
  var _this = this;

  debugWorker('worker [' + this.id + '] onWorkerProcessExitTryToRecyle callback..');

  // we only recycle the process on exit and if it is not in the middle
  // of another recycling
  if (this.firstStart &amp;&amp; !this.isRecycling) {
    debugWorker('trying to recycle worker [' + this.id + '], reason: process exit..');

    this.exit = true;
    this.firstStart = false;

    this.recycle(function () {
      _this.exit = false;
    });
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
      debugWorker('killing worker [' + this.id + '] with custom signal:', this.options.killSignal);
      this._childProcess.kill(this.options.killSignal);
    } else {
      this._childProcess.kill();
    }

    if (!hardKill) {
      this.<span class="apidocCodeKeywordSpan">onWorkerProcessExitTryToRecyle</span>();
    }
  }

  this._childProcess = undefined;
} else {
  debugWorker('there is no child process to kill - worker [' + this.id + ']');
}
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.electron-workers.ElectronWorker.prototype.onWorkerProcessIpcMessage" id="apidoc.element.electron-workers.ElectronWorker.prototype.onWorkerProcessIpcMessage">
        function <span class="apidocSignatureSpan">electron-workers.ElectronWorker.prototype.</span>onWorkerProcessIpcMessage
        <span class="apidocSignatureSpan">(payload)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function onWorkerProcessIpcMessage(payload) {
  var callback = undefined,
      responseData = undefined;

  if (payload &amp;&amp; payload.workerEvent === 'taskResponse') {
    debugWorker('task in worker [' + this.id + '] has ended..');

    callback = this._taskCallback[payload.taskId];
    responseData = payload.response;

    if (!callback || typeof callback !== 'function') {
      debugWorker('worker [' + this.id + '] - callback registered for the task\'s response (' + payload.taskId + ') is not a function
');
      return;
    }

    if (payload.error) {
      return callback(new Error(payload.error.message || 'An error has occurred when trying to process the task'));
    }

    callback(null, responseData);
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.electron-workers.ElectronWorker.prototype.recycle" id="apidoc.element.electron-workers.ElectronWorker.prototype.recycle">
        function <span class="apidocSignatureSpan">electron-workers.ElectronWorker.prototype.</span>recycle
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function recycle() {
  var _this5 = this;

  var cb = undefined,
      revive = undefined;

  debugWorker('recycling worker [' + this.id + ']..');

  for (var _len2 = arguments.length, args = Array(_len2), _key2 = 0; _key2 &lt; _len2; _key2++) {
    args[_key2] = arguments[_key2];
  }

  if (args.length &lt; 2) {
    cb = args[0];
    revive = true;
  } else {
    cb = args[1];
    revive = args[0];
  }

  if (this._childProcess) {
    this.isRecycling = true;
    // mark worker as busy before recycling
    this.isBusy = true;

    this.emit('recycling');

    if (this._hardKill) {
      debugWorker('recycling was stopped because worker [' + this.id + '] was killed by the user..');
      return;
    }

    this.kill();

    debugWorker('trying to re-start child process for worker [' + this.id + ']..');

    this.start(function (startErr) {
      _this5.isRecycling = false;
      // mark worker as free after recycling
      _this5.isBusy = false;

      // if there is a error on worker recycling, revive it on next execute
      if (startErr) {
        _this5.shouldRevive = Boolean(revive);

        debugWorker('couldn\'t recycle worker [' + _this5.id + '], should revive: ' + _this5.shouldRevive);

        cb(startErr);
        _this5.emit('recyclingError', startErr);
        return;
      }

      debugWorker('worker [' + _this5.id + '] has been recycled..');

      _this5.shouldRevive = false;

      cb();

      _this5.emit('recycled');
    });
  } else {
    debugWorker('there is no child process to recycle - worker [' + this.id + ']');
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
  // of another recycling
  if (this.firstStart &amp;&amp; !this.isRecycling) {
    debugWorker('trying to recycle worker [' + this.id + '], reason: process exit..');

    this.exit = true;
    this.firstStart = false;

    this.<span class="apidocCodeKeywordSpan">recycle</span>(function () {
      _this.exit = false;
    });
  }
};

ElectronWorker.prototype.onWorkerProcessIpcMessage = function onWorkerProcessIpcMessage(payload) {
  var callback = undefined,
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.electron-workers.ElectronWorker.prototype.start" id="apidoc.element.electron-workers.ElectronWorker.prototype.start">
        function <span class="apidocSignatureSpan">electron-workers.ElectronWorker.prototype.</span>start
        <span class="apidocSignatureSpan">(cb)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function start(cb) {
  var _this2 = this;

  var isDone = false;

  if (!isValidConnectionMode(this.options.connectionMode)) {
    return cb(new Error('invalid connection mode: ' + this.options.connectionMode));
  }

  debugWorker('starting worker [' + this.id + ']..');

  this.findFreePort(function (err, port) {
    var childArgs = undefined,
        childOpts = undefined;

    var _options = _this2.options;
    var electronArgs = _options.electronArgs;
    var pathToElectron = _options.pathToElectron;
    var pathToScript = _options.pathToScript;
    var hostEnvVarName = _options.hostEnvVarName;
    var portEnvVarName = _options.portEnvVarName;
    var host = _options.host;
    var debug = _options.debug;
    var debugBrk = _options.debugBrk;
    var env = _options.env;
    var stdio = _options.stdio;
    var connectionMode = _options.connectionMode;

    if (!env) {
      env = {};
    }

    childArgs = electronArgs.slice();
    childArgs.unshift(pathToScript);

    if (debugBrk != null) {
      childArgs.unshift('--debug-brk=' + debugBrk);
    } else if (debug != null) {
      childArgs.unshift('--debug=' + debug);
    }

    if (err) {
      debugWorker('couldn\'t find free port for worker [' + _this2.id + ']..');
      return cb(err);
    }

    _this2.port = port;

    childOpts = {
      env: _extends({}, env, {
        ELECTRON_WORKER_ID: _this2.id,
        // propagate the DISPLAY env var to make it work on LINUX
        DISPLAY: process.env.DISPLAY
      })
    };

    // we send host and port as env vars to child process in server mode
    if (connectionMode === 'server') {
      childOpts.stdio = 'pipe';
      childOpts.env[hostEnvVarName] = host;
      childOpts.env[portEnvVarName] = port;
    } else if (connectionMode === 'ipc') {
      childOpts.stdio = ['pipe', 'pipe', 'pipe', 'ipc'];
    }

    if (stdio != null) {
      childOpts.stdio = stdio;
    }

    debugWorker('spawning process for worker [' + _this2.id + '] with args:', childArgs, 'and options:', childOpts);

    _this2._childProcess = _child_process2['default'].spawn(pathToElectron, childArgs, childOpts);

    // ipc connection is required for ipc mode
    if (connectionMode === 'ipc' &amp;&amp; !_this2._childProcess.send) {
      return cb(new Error('ipc mode requires a ipc connection, if you\'re using stdio option make sure you are setting up ipc'));
    }

    _this2._handleSpawnError = function (spawnError) {
      debugWorker('worker [' + this.id + '] spawn error callback..');

      if (!this.firstStart) {
        isDone = true;
        this._earlyError = true;
        debugWorker('worker [' + this.id + '] start was canceled because an early error: ' + spawnError.message);
        cb(spawnError);
      }
    };

    _this2._handleSpawnError = _this2._handleSpawnError.bind(_this2);

    _this2._childProcess.once('error', _this2._handleSpawnError);

    _this2._childProcess.on('error', _this2.onWorkerProcessError);

    _this2._childProcess.on('exit', _this2.onWorkerProcessExitTryToRecyle);

    if (connectionMode === 'ipc') {
      _this2._childProcess.on('message', _this2.onWorkerProcessIpcMessage);
    }

    _this2.emit('processCreated');

    setImmediate(function () {
      // the workers were killed explicitly by the user
      if (_this2._hardKill || isDone) {
        return;
      }

      if (_this2._childProcess == null) {
        debugWorker('There is no child process for worker [' + _this2.id + ']..');
        return cb(new Error('There is no child process for worker'));
      }

      debugWorker('checking if worker [' + _this2.id + '] is alive..');

      _this2.checkAlive(function (checkAliveErr) {
        if (isDone) {
          return;
        }

        if (checkAliveErr) {
          debugWorker('worker [' + _this2.id + '] is not alive..');
          return cb(checkAliveErr);
        }

        _this2._earlyError = false;
        _this2._childProcess.removeListener('error', _this2._handleSpawnError);

        if (!_this2.firstStart) {
          _this2.firstStart = true;
        }

        debugWorker('worker [' + _this2.id + '] ...</pre></li>
    <li>example usage<pre class="apidocCodePre">...
var electronWorkers = require('electron-workers')({
connectionMode: 'server',
pathToScript: 'script.js',
timeout: 5000,
numberOfWorkers: 5
});

electronWorkers.<span class="apidocCodeKeywordSpan">start</span>(function(startErr) {
if (startErr) {
  return console.error(startErr);
}

// `electronWorkers` will send your data in a POST request to your electron script
electronWorkers.execute({ someData: 'someData' }, function(err, data) {
  if (err) {
...</pre></li>
    </ul>


</div>

<div class="apidocFooterDiv">
    [ this document was created with
    <a href="https://github.com/kaizhu256/node-utility2" target="_blank">utility2</a>
    ]
</div>
</div>
</body></html>